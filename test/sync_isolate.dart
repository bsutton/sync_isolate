#! /usr/bin/env dcli

@Timeout(Duration(seconds: 60))
library spawn_test;

// ignore: prefer_relative_imports
import 'dart:async';
import 'dart:io';

import 'package:dcli/dcli.dart' hide NamedLock;
import 'package:path/path.dart';
import 'package:sync_isolate/src/isolate_channel.dart';
import 'package:sync_isolate/src/message.dart';
import 'package:sync_isolate/src/message_response.dart';
import 'package:sync_isolate/src/named_lock.dart';
import 'package:sync_isolate/src/process_in_isolate.dart';
import 'package:sync_isolate/src/process_settings.dart';
import 'package:sync_isolate/src/simple_in_isolate.dart';
import 'package:test/test.dart';

/// dcli script generated by:
/// dcli create %scriptname%
///
/// See
/// https://pub.dev/packages/dcli#-installing-tab-
///
/// For details on installing dcli.
///
void main(List<String> args) async {
  test('spawn', () async {
    await withTempDirAsync((lockPath) async {
      const lockName = 'spawn_test';
      final isolate = NamedLock.isolateID;
      touch(join(lockPath, '.$pid.$isolate.$lockName'), create: true);

      await NamedLock(name: lockName, lockPath: lockPath)
          .withLockAsync(() async {
        _spawn(1);
        // _spawn(2);
        // _spawn(3);
      });
    });
  });
}

void _spawn(int index) {
  // await NamedLock(name: lockName).withLockAsync(() async {
  final channel = IsolateChannel(
      process: ProcessSettings('dcli_unit_tester',
          args: ['-n', '-l', '1', '-o', '1']));

  startIsolate(channel);

  MessageResponse? response;
  do {
    processLogger(() => 'Primary calling Mailbox.take()');
    try {
      final messageData =
          channel.toPrimaryIsolate.take(timeout: const Duration(seconds: 4));
      // await Future.delayed(const Duration(seconds: 20), () {});
      processLogger(() => 'take returned with data');
      response = MessageResponse.fromData(messageData)
        ..onStdout(print)
        ..onStderr(print)
        ..onException((exception) => throw exception);
    } on TimeoutException catch (e) {
      // ignore: avoid_print
      processLogger(
          () => 'Timeout waiting for response from isolate: ${e.message}');
      // await Future.delayed(const Duration(seconds: 3), () {});
    }
  } while (response?.messageType != MessageType.exitCode);
  processLogger(() => 'primary: received exit message');

  channel.close();
}
